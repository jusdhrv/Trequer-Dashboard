-- Enable the pgcrypto extension for UUID generation if not already enabled
create extension if not exists "pgcrypto";

-- Enable the pg_cron extension for scheduled jobs if not already enabled
create extension if not exists "pg_cron";

-- Create the sensor_configs table
create table if not exists sensor_configs (
    id text primary key,
    name text not null,
    unit text not null,
    pin text not null,
    signal_type text not null check (signal_type in ('analog', 'digital')),
    reading_interval integer not null,
    is_enabled boolean not null default true,
    description text,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create the sensor_readings table with foreign key constraint
create table if not exists sensor_readings (
    id bigint generated by default as identity primary key,
    sensor_id text references sensor_configs(id) on delete cascade,
    value double precision not null,
    timestamp timestamp with time zone default timezone('utc'::text, now()) not null,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create an index on timestamp for better query performance
create index if not exists idx_sensor_readings_timestamp on sensor_readings(timestamp);

-- TODO: Replace this hardcoded retain time to use data from Settings
-- -- Create a function to delete old readings (older than 14 days)
-- create or replace function delete_old_sensor_readings()
-- returns void
-- language plpgsql
-- as $$
-- begin
--     delete from sensor_readings
--     where timestamp < now() - interval '14 days';
-- end;
-- $$;

-- -- Create a scheduled job to run the cleanup function daily at midnight
-- select cron.schedule(
--     'cleanup-old-readings',   -- name of the cron job
--     '0 0 * * *',             -- run at midnight every day
--     $$select delete_old_sensor_readings();$$
-- );

-- Enable Row Level Security (RLS)
alter table sensor_configs enable row level security;
alter table sensor_readings enable row level security;

-- Create policies that allow all operations for authenticated users and service role
create policy "Allow all operations for authenticated users and service role on sensor_configs"
    on sensor_configs
    for all
    using (auth.role() in ('authenticated', 'service_role'))
    with check (auth.role() in ('authenticated', 'service_role'));

create policy "Allow all operations for authenticated users and service role on sensor_readings"
    on sensor_readings
    for all
    using (auth.role() in ('authenticated', 'service_role'))
    with check (auth.role() in ('authenticated', 'service_role'));

-- Create policies that allow read-only access for anonymous users
create policy "Allow read-only access for anonymous users on sensor_configs"
    on sensor_configs
    for select
    to anon
    using (true);

create policy "Allow read-only access for anonymous users on sensor_readings"
    on sensor_readings
    for select
    to anon
    using (true); 